package com.exasol.adapter.dialects.exasol;

import com.exasol.adapter.AdapterProperties;
import com.exasol.adapter.dialects.IdentifierConverter;
import com.exasol.adapter.jdbc.BaseTableMetadataReader;
import com.exasol.adapter.jdbc.ColumnMetadataReader;
import com.exasol.adapter.metadata.ColumnMetadata;
import com.exasol.adapter.metadata.TableMetadata;
import com.exasol.errorreporting.ExaError;
import com.exasol.jdbc.EXAResultSet;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.logging.Logger;

import static com.exasol.adapter.jdbc.RemoteMetadataReaderConstants.ANY_COLUMN;
import static com.exasol.adapter.jdbc.RemoteMetadataReaderConstants.ANY_TABLE;

/**
 * Specific table reader for Exasol, reading column metadata in bulk.
 *
 * TODO - design decision; while the default JDBC implementation is especially bad for Exasol, the following
 *        approach should still be valid for all JDBC-compliant databases / drivers...
 */
public class ExasolTableMetadataReader extends BaseTableMetadataReader {
    private static final Logger LOGGER = Logger.getLogger(ExasolTableMetadataReader.class.getName());

    /**
     * Create a new instance of a {@link ExasolTableMetadataReader}.
     *
     * @param connection           JDBC connection to remote data source
     * @param columnMetadataReader reader to be used to map the tables columns
     * @param properties           user-defined adapter properties
     * @param identifierConverter  converter between source and Exasol identifiers
     */
    public ExasolTableMetadataReader(Connection connection, ColumnMetadataReader columnMetadataReader,
            AdapterProperties properties, IdentifierConverter identifierConverter) {
        super(connection, columnMetadataReader, properties, identifierConverter);
    }

    // arbitrary border to switch between default iterative and "all in" column scan
    static final double filter_ratio_threshold = 0.1;

    @Override
    public List<TableMetadata> mapTables(ResultSet remoteTables, List<String> filteredTables) throws SQLException {
        // TODO: the decision tree may be over-engineered; up for discussion

        // must not iterate the ResultSet yet, because super implementation will immediately call next()
        long numberOfTables = ((EXAResultSet) remoteTables).getNumberOfRows();
        long filteredTableCount = filteredTables.size();

        if( numberOfTables == 0 ) {
            LOGGER.warning(() -> ExaError.messageBuilder("W-VSEXA-6")
                    .message("Table scan did not find any tables. This can mean that either" //
                            + " a) the source does not contain tables (yet)," + " b) the table type is not supported" //
                            + " c) the user does not have access permissions.")
                    .mitigation("Please check that the source actually contains tables. " //
                            + " Also check the spelling and exact case of any catalog or schema name you provided.")
                    .toString());
            return Collections.emptyList();
        }

        if (filteredTableCount > 0 && filteredTableCount < filter_ratio_threshold * numberOfTables) {
            // strong filter, use default jdbc implementation
            return super.mapTables(remoteTables, filteredTables);
        }

        return mapTablesBatch(remoteTables, filteredTables);
    }

    /**
     * Optimized version of BaseTableMetadataReader::mapTables, which uses a single call to
     * DatabaseMetadata::getColumns instead of one call per table. Massive speedup for Exasol clusters.
     *
     * @param remoteTables   ResultSet generated by DatabaseMetadata::getTables(), sorted by TABLE_TYPE, TABLE_CAT, TABLE_SCHEM, TABLE_NAME
     * @param filteredTables Optional list of table names to accept; case-sensitive, no wildcard support
     * @return Metadata for mapped tables; may be empty.
     * @throws SQLException When any ResultSet operation fails
     */
    private List<TableMetadata> mapTablesBatch(ResultSet remoteTables, List<String> filteredTables)
            throws SQLException {
        assert (this.columnMetadataReader instanceof ExasolColumnMetadataReader);
        final ExasolColumnMetadataReader columnReader = (ExasolColumnMetadataReader) this.columnMetadataReader;

        // step 1: go through table ResultSet once, put them into a sorted map (sort by TABLE_TYPE is bad)
        SortedMap<String, SortedMap<String, String>> sortedSchemas = new TreeMap<>();
        int totalTables = 0;
        while (remoteTables.next()) {
            final String schemaName = remoteTables.getString("TABLE_SCHEM");
            SortedMap<String, String> sortedTables = sortedSchemas.computeIfAbsent(schemaName, (String) -> new TreeMap<>());

            final String tableName = readTableName(remoteTables);
            if (isTableSupported(filteredTables, tableName)) {
                final String comment = Optional.ofNullable(readComment(remoteTables)).orElse("");
                sortedTables.put(tableName, comment);
                totalTables++;
            }
        }

        if (totalTables == 0) {
            // by check W-VSEXA-5, the unfiltered table list was not empty.
            LOGGER.warning(() -> ExaError.messageBuilder("W-VSEXA-6")
                    .message("Table scan did not find any of the listed tables. This can mean that either" //
                            + " a) the table type is not supported" //
                            + " b) the names do not match up" //
                            + " c) the user does not have access permissions.")
                    .mitigation("Please check the spelling and exact case of any catalog or schema name you provided. Also check that the remote user does have access to the tables.")
                    .toString());
            return Collections.emptyList();
        }

        // column list is sorted by TABLE_CAT (const), TABLE_SCHEM, TABLE_NAME, COLUMN_ORDINAL_POSITION
        // TODO - maybe exchange the SchemaNameFilter with the schema name from the SortedMap if there is only one entry. However, non-qualified Virtual Schemas are broken anyway...
        ResultSet columnList = this.connection.getMetaData().getColumns(getCatalogNameFilter(), getSchemaNameFilter(),
                ANY_TABLE, ANY_COLUMN);
        if (!columnList.next()) {
            LOGGER.warning(() -> ExaError.messageBuilder("W-VSEXA-7")
                    .message("Column scan did not find any columns for schema {{schema_name}}. This should only happen when the schema contains only views that have not been initialized yet.")
                    .mitigation("Please check the remote system.")
                    .toString());
            return Collections.emptyList();
        }

        // step 2: now we can "merge sort" table and column list based on sorted table name
        final List<TableMetadata> mappedTables = new ArrayList<>();
        for (Map.Entry<String, SortedMap<String,String>> schemaEntry : sortedSchemas.entrySet()) {
            String schemaName = schemaEntry.getKey();
            // skip ahead for schema name
            while( schemaName.compareTo(columnList.getString("TABLE_SCHEM")) > 0 ) {
                if( !columnList.next() ) {
                    // end of the rope; no more columns
                    break;
                }
            }
            if( columnList.isAfterLast() ) {
                break;
            }
            if( schemaName.compareTo(columnList.getString("TABLE_SCHEM")) < 0 ) {
                // the schema we were looking for does not exist
                continue;
            }

            for( Map.Entry<String, String> tableEntry : schemaEntry.getValue().entrySet() ) {

                String tableName = tableEntry.getKey();
                String tableComment = tableEntry.getValue();
                final List<ColumnMetadata> columns = columnReader.mapColumns(tableName, columnList);
                if (columns.size() == 0) {
                    logSkippingTableWithEmptyColumns(tableName);
                    continue;
                }

                TableMetadata mappedTable = new TableMetadata(adjustIdentifierCase(tableName), DEFAULT_TABLE_ADAPTER_NOTES,
                        columns, tableComment);
                mappedTables.add(mappedTable);
                LOGGER.finer(() -> "Read table metadata: " + mappedTable.describe());
                validateMappedTablesListSize(mappedTables);
            }
        }

        if( mappedTables.isEmpty() ) {
            LOGGER.warning(() -> ExaError.messageBuilder("W-VSEXA-8")
                    .message("Column mapping filtered out all available table columns. This indicates that the remote system only contains incompatible data types.")
                    .mitigation("Please check the remote system.")
                    .toString());
        }

        return mappedTables;
    }
}
